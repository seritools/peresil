var searchIndex = {};
searchIndex["peresil"] = {"doc":"A simple and simplistic parsing library","items":[[3,"Progress","peresil","Tracks where the parser currently is and if it is successful.",null,null],[12,"point","","The current location.",0,null],[12,"status","","If the point indicates the location of a successful or failed parse.",0,null],[3,"ParseMaster","","The main entrypoint to parsing.",null,null],[3,"Alternate","","Follows the first successful parsing path.",null,null],[3,"StringPoint","","Tracks the location of parsing in a string, the most common case.",null,null],[12,"s","","The portion of the input string to start parsing next",1,null],[12,"offset","","How far into the original string we are",1,null],[4,"Status","","An analog to `Result`, specialized for parsing.",null,null],[13,"Success","","",2,null],[13,"Failure","","",2,null],[6,"Identifier","","Matches a literal string to a specific type, usually an enum.",null,null],[8,"Point","","A location in the parsed data",null,null],[10,"zero","","The initial point",3,{"inputs":[],"output":{"name":"self"}}],[8,"Recoverable","","Indicate if an error should terminate all parsing.",null,null],[10,"recoverable","","",4,null],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"success","","",0,{"inputs":[{"name":"p"},{"name":"t"}],"output":{"name":"progress"}}],[11,"failure","","",0,{"inputs":[{"name":"p"},{"name":"e"}],"output":{"name":"progress"}}],[11,"map","","Convert the success value, if there is one.",0,null],[11,"map_err","","Convert the failure value, if there is one.",0,null],[11,"optional","","Returns the value on success, or rewinds the point and returns\n`None` on failure.",0,null],[11,"fmt","","",5,null],[11,"eq","","",5,null],[11,"ne","","",5,null],[11,"new","","",5,{"inputs":[],"output":{"name":"parsemaster"}}],[11,"optional","","Returns the value on success, or rewinds the point and returns\n`None` on a recoverable failure. Non-recoverable failures are\npropagated.",5,null],[11,"alternate","","Run sub-parsers in order until one succeeds.",5,null],[11,"zero_or_more","","Runs the parser until it fails.",5,null],[11,"finish","","When parsing is complete, provide the final result and gain\naccess to all failures. Will be recycled and may be used for\nfurther parsing.",5,null],[11,"one","","Run one alternative parser.",6,null],[11,"finish","","Complete the alternatives, returning the first successful branch.",6,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","",1,null],[11,"zero","","",1,{"inputs":[],"output":{"name":"stringpoint"}}],[11,"new","","",1,{"inputs":[{"name":"str"}],"output":{"name":"stringpoint"}}],[11,"is_empty","","",1,null],[11,"to","","Slices the string.",1,null],[11,"consume_to","","Advances the point by the number of bytes. If the value is\n`None`, then no value was able to be consumed, and the result\nis a failure.",1,null],[11,"consume_literal","","Advances the point if it starts with the literal.",1,null],[11,"consume_identifier","","Iterates through the identifiers and advances the point on the\nfirst matching identifier.",1,null],[14,"try_parse","","An analog to `try!`, but for `Progress`",null,null]],"paths":[[3,"Progress"],[3,"StringPoint"],[4,"Status"],[8,"Point"],[8,"Recoverable"],[3,"ParseMaster"],[3,"Alternate"]]};
initSearch(searchIndex);
